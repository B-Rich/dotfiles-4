# Best Goddamn zsh prompt in the whole world.
# Author: Seth House <seth@eseth.com>
# thanks to Phil of phil's prompt: http://aperiodic.net/phil/prompt/
# and Frank Terbeck <ft@bewatermyfriend.org> for the VCS_INFO work

fpath=( ~/.zsh_functions $fpath )

autoload -U colors
autoload -U promptinit
autoload -Uz vcs_info

colors
# set some color shortcuts
for COLOR in RED GREEN YELLOW WHITE BLACK CYAN; do
    eval PR_$COLOR='%{$fg[${(L)COLOR}]%}'
    eval PR_B$COLOR='%{$fg_bold[${(L)COLOR}]%}'
done
PR_RESET="%{${reset_color}%}";

# Set up VCS_INFO
zstyle ':vcs_info:*' enable hg git bzr svn
zstyle ':vcs_info:(hg|git):*' get-revision true
zstyle ':vcs_info:(hg|git):*' check-for-changes true

zstyle ':vcs_info:*' formats "($PR_WHITE%s$PR_BBLACK)[%i$PR_WHITE%u$PR_BBLACK %b %m]" # rev, changes, branch, misc
zstyle ':vcs_info:*' actionformats "($PR_WHITE%s$PR_BBLACK|$PR_RED%a$PR_BBLACK)[%i$PR_WHITE%u$PR_BBLACK %b %m]"

zstyle ':vcs_info:hg:*' get-bookmarks true

zstyle ':vcs_info:hg:*' get-mq true
zstyle ':vcs_info:hg:*' get-unapplied true
zstyle ':vcs_info:hg:*' patch-format "mq:$PR_WHITE%n/%c$PR_BBLACK %g"
zstyle ':vcs_info:hg:*' nopatch-format "mq:$PR_WHITE%n/%c$PR_BBLACK %g"

zstyle ':vcs_info:hg:*' unstagedstr "$PR_BGREEN+$PR_BBLACK"
zstyle ':vcs_info:hg:*' hgrevformat "$PR_WHITE%r$PR_BBLACK" # only show local rev.
zstyle ':vcs_info:hg:*' branchformat "%b" # only show branch

# zstyle ':vcs_info:hg:*' use-simple true
# zstyle ':vcs_info:*+*:*' debug true

zstyle ':vcs_info:hg+set-hgrev-format:*' hooks hg-storerev hg-hashfallback
zstyle ':vcs_info:hg+set-message:*' hooks mq-vcs hg-branchhead

### Store the localrev and global hash for use in other hooks
function +vi-hg-storerev() {
    user_data[localrev]=${hook_com[localrev]}
    user_data[hash]=${hook_com[hash]}
}

### Dynamically set hgrevformat based on if the local rev is available
# We don't always know the local revision, e.g. if use-simple is set
# Truncate long hash to 12-chars but also allow for multiple parents
function +vi-hg-hashfallback() {
    if [[ -z ${hook_com[localrev]} ]] ; then
        local -a parents

        parents=( ${(s:+:)hook_com[hash]} )
        parents=( ${(@r:12:)parents} )
        hook_com[rev-replace]="$PR_WHITE${(j:+:)parents}$PR_BBLACK"

        ret=1
    fi
}

### Show when mq itself is under version control
function +vi-mq-vcs() {
    # if [[ -d ${hook_com[base]}/.hg/patches/.hg ]]; then
        # hook_com[hg-mqpatch-string]="mq:${hook_com[hg-mqpatch-string]}"
    # fi
}

### Show marker when the working directory is not on a branch head
# This may indicate that running `hg up` will do something
function +vi-hg-branchhead() {
    local branchheadsfile i_tiphash i_branchname
    local -a branchheads

    local branchheadsfile=${hook_com[base]}/.hg/branchheads.cache

    # Bail out if any mq patches are applied
    [[ -s ${hook_com[base]}/.hg/patches/status ]] && return 0

    if [[ -r ${branchheadsfile} ]] ; then
        while read -r i_tiphash i_branchname ; do
            branchheads+=( $i_tiphash )
        done < ${branchheadsfile}

        if [[ ! ${branchheads[(i)${user_data[hash]}]} -le ${#branchheads} ]] ; then
            hook_com[revision]="${PR_RED}^${PR_BBLACK}${hook_com[revision]}"
        fi
    fi
}

### Selectively enable/disable use-simple for certain repositories
# Some repos are just too big to call hg on in a prompt, but you might not want
# to set use-simple for *all* repos. This example shows how to selectively set
# it. For brevity, this simply looks at the name of the base directory, but you
# could also parse the hgrc file for [paths] entries, or you could call out to
# `du` to base it off the file size of a repo, etc.
zstyle ':vcs_info:hg:*' hg-use-simple-for netbeans hgtest_netbeans
zstyle ':vcs_info:hg+pre-get-data:*' hooks hg-use-simple

function +vi-hg-use-simple() {
    local basedir=${@[1]} orig_setting

    zstyle -a ":vcs_info:${vcs}:${usercontext}:${rrn}" \
        "hg-use-simple-for" use_simple_for

    if [[ -n $use_simple_for && ${use_simple_for[(i)${basedir:t}]} \
            -le ${#use_simple_for} ]] ; then
        zstyle ':vcs_info:hg:*' use-simple true
    else
        zstyle -s ":vcs_info:${vcs}:${usercontext}:${rrn}" \
            "use-simple" orig_setting || orig_setting=false

        zstyle ':vcs_info:hg:*' use-simple $orig_setting
    fi
}


# Executed before each prompt
function precmd {
    vcs_info
    setprompt
    venv_rprompt
}


# Executed after a command has been read and is to be executed.
function preexec {
    # if running gnu screen, set the window name to the last run command
    # FIXME any way to make this not change certain window titles (by window
    # number or if a title isn't already set?)
    if [[ "$TERM" =~ "screen" ]]; then
        local CMD=${1[(wr)^(*=*|ssh|sudo|-*)]}
        echo -ne "\ek$CMD\e\\"
    fi
}

# Encapsulate building the prompt.
function setprompt {
    # display in yellow if the current dir isn not writable
    local pr_pwd="$PR_BGREEN"$(test -w $PWD || print "$PR_BYELLOW")"%~$PR_RESET"

    # show job count
    local pr_jobs="$PR_BBLACK%j$PR_RESET"

    # display the hostname only if ssh-ed into another box
    local pr_user="$PR_BBLACK<$PR_RESET%n"$(test -z $SSH_CLIENT || print '@%m')"$PR_BBLACK>$PR_RESET"

    # make the prompt red if the last command exited unsuccessfully
    local pr_prompt="%(0?..$PR_BRED)%#$PR_RESET "

    # display vcs information for the current dir (if any)
    if [ -n "$vcs_info_msg_0_" ]; then
        local pr_vcs="$PR_BBLACK$vcs_info_msg_0_$PR_RESET"
    fi

    # FIXME: is there a way to get the width from the real variables without
    # the color escapes? repeating the prompt twice sucks.
    if [[ -z $SSH_CLIENT ]]; then
        local width=$((${#${(%):-<%n> %~ }} + ${#${(%):-$vcs_info_msg_0_}} + 1))
    else
        local width=$((${#${(%):-<%n@%m> %~ }} + ${#${(%):-$vcs_info_msg_0_}} + 1))
    fi

    # RANDOM will not change unless referenced in parent shell
    # echo $RANDOM &>/dev/null
    # local pr_pet=$(pet_wander $width)

    PROMPT="$pr_user $pr_pwd $pr_vcs $pr_pet"$'\n'"$pr_jobs $pr_prompt"
}


# A domestic animal, the _tame dog_ (_Canis familiaris_)
pet_wander () {
    # Draw enough padding to reach the end of the window;
    # pet likes to wander this space

    local pet="d"

    if [[ $[${RANDOM}%20] == 0 ]]; then
        pet="^"
    elif [[ $[${RANDOM}%50] == 0 ]]; then
        pet="D"
    fi

    local width=$1
    local padding=$(($COLUMNS - $width - 1))
    local position=$[${RANDOM}%$padding]
    local left=$((padding - position))

    local pr_pet="%{$bg_bold[white]$fg[black]%}$pet%{$reset_color%}"

    echo -ne "%{$fg_bold[black]%}"
    echo -ne "${(l/$left//./)}"
    echo -ne "$pr_pet"
    echo -ne "%{$fg_bold[black]%}"
    echo -ne "${(r/$position//./)}"
    echo -ne "%{$reset_color%}"
}

venv_rprompt () {
    if [[ -n $VIRTUAL_ENV ]]; then
        RPROMPT="$PR_BBLACK venv:$(basename $VIRTUAL_ENV)$PR_RESET"
    else
        RPROMPT=""
    fi
}

# function zle-keymap-select {
    # VIMODE="${${KEYMAP/vicmd/ M:command}/(main|viins)/}"
    # zle reset-prompt
# }
# zle -N zle-keymap-select
#
########## Or this one?:
# function zle-line-init zle-keymap-select {
    # RPS1="${${KEYMAP/vicmd/-- NORMAL --}/(main|viins)/-- INSERT --}"
    # RPS2=$RPS1
    # zle reset-prompt
# }
# zle -N zle-line-init
# zle -N zle-keymap-select
