# Best Goddamn zsh prompt in the whole world.
# Author: Seth House <seth@eseth.com>

fpath=( ~/.zsh_functions $fpath )
[[ -d $HOME/.zsh_functions/VCS_Info ]] \
    && fpath[1]=( ${fpath[1]} ~/.zsh_functions/**/*~*/(CVS)#(/) )

autoload -U colors && colors
autoload -U promptinit
autoload -Uz vcs_info

local cr c1 c2 c3 c4
cr="%{${reset_color}%}"
c1="%{$fg[white]%}"
c2="%{$fg_bold[black]%}"
c3="%{$fg_bold[green]%}"
c4="%{$fg[red]%}"
c5="%{$fg[yellow]%}"

# Set up VCS_INFO
zstyle ':vcs_info:*' enable git hg bzr svn
zstyle ':vcs_info:(hg*|git*):*' get-revision true
zstyle ':vcs_info:(hg*|git*):*' check-for-changes true

zstyle ':vcs_info:hg*' formats "(%s)[%i%u %b %m]" # rev+changes branch misc
zstyle ':vcs_info:hg*' actionformats "(%s|${c1}%a${c2})[%i%u %b %m]"

zstyle ':vcs_info:hg*:netbeans' use-simple true
zstyle ':vcs_info:hg*:*' get-bookmarks true
zstyle ':vcs_info:hg*:*' get-mq true

zstyle ':vcs_info:hg*:*' get-unapplied true
zstyle ':vcs_info:hg*:*' patch-format "mq(%g):%n/%c %p"
zstyle ':vcs_info:hg*:*' nopatch-format "mq(%g):%n/%c %p"

zstyle ':vcs_info:hg*:*' unstagedstr "${c3}+${c2}"
zstyle ':vcs_info:hg*:*' hgrevformat "%r" # only show local rev.
zstyle ':vcs_info:hg*:*' branchformat "%b" # only show branch

zstyle ':vcs_info:git*' formats "(%s)[%12.12i %c%u %b %m]" # hash changes branch misc
zstyle ':vcs_info:git*' actionformats "(%s|${c1}%a${c2})[%12.12i %c%u %b %m]"

zstyle ':vcs_info:git*:*' stagedstr "${c3}S${c2}"
zstyle ':vcs_info:git*:*' unstagedstr "${c4}U${c2}"

# zstyle ':vcs_info:hg:*:-all-' command fakehg
# zstyle ':vcs_info:*+*:*' debug true

zstyle ':vcs_info:hg*+set-hgrev-format:*' hooks hg-hashfallback
zstyle ':vcs_info:hg*+set-message:*' hooks mq-vcs hg-storerev hg-branchhead

### Store the localrev and global hash for use in other hooks
function +vi-hg-storerev() {
    user_data[localrev]=${hook_com[localrev]}
    user_data[hash]=${hook_com[hash]}
}

### Dynamically set hgrevformat based on if the local rev is available
# We don't always know the local revision, e.g. if use-simple is set
# Truncate long hash to 12-chars but also allow for multiple parents
function +vi-hg-hashfallback() {
    if [[ -z ${hook_com[localrev]} ]] ; then
        local -a parents

        parents=( ${(s:+:)hook_com[hash]} )
        parents=( ${(@r:12:)parents} )
        hook_com[rev-replace]="${(j:+:)parents}"

        ret=1
    fi
}

### Show when mq itself is under version control
function +vi-mq-vcs() {
    # if [[ -d ${hook_com[base]}/.hg/patches/.hg ]]; then
        # hook_com[hg-mqpatch-string]="mq:${hook_com[hg-mqpatch-string]}"
    # fi
}

### Show marker when the working directory is not on a branch head
# This may indicate that running `hg up` will do something
function +vi-hg-branchhead() {
    local branchheadsfile i_tiphash i_branchname
    local -a branchheads

    local branchheadsfile=${hook_com[base]}/.hg/branchheads.cache

    # Bail out if any mq patches are applied
    [[ -s ${hook_com[base]}/.hg/patches/status ]] && return 0

    if [[ -r ${branchheadsfile} ]] ; then
        while read -r i_tiphash i_branchname ; do
            branchheads+=( $i_tiphash )
        done < ${branchheadsfile}

        if [[ ! ${branchheads[(i)${user_data[hash]}]} -le ${#branchheads} ]] ; then
            hook_com[revision]="${c4}^${c2}${hook_com[revision]}"
        fi
    fi
}

zstyle ':vcs_info:git*+set-message:*' hooks git-st

# Show number of commits HEAD is ahead-of or behind remote HEAD.
function +vi-git-st() {
    local ahead behind
    local -a gitstatus

    # for git prior to 1.7
    # ahead=$(git rev-list origin/${hook_com[branch]}..HEAD | wc -l)
    ahead=$(git rev-list ${hook_com[branch]}@{upstream}..HEAD 2>/dev/null | wc -l)
    (( $ahead )) && gitstatus+=( "${c3}+${ahead}${c2}" )

    # for git prior to 1.7
    # behind=$(git rev-list HEAD..origin/${hook_com[branch]} | wc -l)
    behind=$(git rev-list HEAD..${hook_com[branch]}@{upstream} 2>/dev/null | wc -l)
    (( $behind )) && gitstatus+=( "${c4}-${behind}${c2}" )

    hook_com[misc]+=${(j:/:)gitstatus}
}

# Executed before each prompt
function precmd {
    vcs_info
    setprompt
    venv_rprompt
}


# Executed after a command has been read and is to be executed.
function preexec {
    # if running gnu screen, set the window name to the last run command
    # FIXME any way to make this not change certain window titles (by window
    # number or if a title isn't already set?)
    if [[ "$TERM" =~ "screen" ]]; then
        local CMD=${1[(wr)^(*=*|ssh|sudo|-*)]}
        echo -ne "\ek$CMD\e\\"
    fi
}

function setprompt() {
    local -a lines infoline
    local x i pet dungeon filler i_width i_pad

    # A domestic animal, the _tame dog_ (_Canis familiaris_)
    pet=d

    ### First, assemble the top line
    # Current dir; show in yellow if not writable
    [[ -w $PWD ]] && infoline+=( ${c3} ) || infoline+=( ${c5} )
    infoline+=( "%~${cr} " )

    # Username & host
    infoline+=( "%n" )
    [[ -n $SSH_CLIENT ]] && infoline+=( "@%m" )

    # Strip color to find text width & make the full-width filler
    zstyle -T ":pr-nethack:" show-pet && i_pad=4 || i_pad=0


    i_width=${(S%%)infoline//\%\{*\%\}} # search-and-replace color escapes
    filler="${c2}${(l:$(( $COLUMNS - ${(%)${#i_width}} - $i_pad ))::.:)}${cr}"
    infoline[2]=( "${infoline[2]} ${filler} " )

    ### Now, assemble all prompt lines
    lines+=( ${(j::)infoline} )
    [[ -n ${vcs_info_msg_0_} ]] && lines+=( "${c2}${vcs_info_msg_0_}${cr}" )
    lines+=( "%(1j.${c2}%j${cr} .)%(0?.${c1}.${c4})%#${cr} " )

    ### Add dungeon floor to each line
    # Allow easy toggling of pet display
    if zstyle -T ":pr-nethack:" show-pet ; then
        dungeon=${(l:$(( ${#lines} * 3 ))::.:)}
        dungeon[$[${RANDOM}%${#dungeon}]+1]=$pet

        for (( i=1; i < $(( ${#lines} + 1 )); i++ )) ; do
            case $i in
                1) x=1;; 2) x=4;; 3) x=7;; 4) x=10;;
            esac
            lines[$i]="${c2}${dungeon[x,$(( $x + 2 ))]} ${lines[$i]}${cr}"
        done
    fi

    ### Finally, set the prompt
    PROMPT=${(F)lines}
}

venv_rprompt () {
    if [[ -n $VIRTUAL_ENV ]]; then
        RPROMPT="${c1} venv:$(basename $VIRTUAL_ENV)${cr}"
    else
        RPROMPT=""
    fi
}

# function zle-keymap-select {
    # VIMODE="${${KEYMAP/vicmd/ M:command}/(main|viins)/}"
    # zle reset-prompt
# }
# zle -N zle-keymap-select
#
########## Or this one?:
# function zle-line-init zle-keymap-select {
    # RPS1="${${KEYMAP/vicmd/-- NORMAL --}/(main|viins)/-- INSERT --}"
    # RPS2=$RPS1
    # zle reset-prompt
# }
# zle -N zle-line-init
# zle -N zle-keymap-select
